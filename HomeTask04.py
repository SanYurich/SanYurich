# 1.Создать и заполнить файл случайными целыми значениями. 
# Выполнить сортировку содержимого файла по возрастанию. 

# import random 

# def rand_number(min,max):
#     list = []
#     for i in range(max):
#         list.append(random.randint(min,max))
#     return list

# rand_list = rand_number(0,20)
# print(rand_list)

# with open('file_random_numbers.txt', 'w') as data:
#     data.writelines(f"{rand_list}")
#     data.writelines("\n")

# def selection_sort(arr):        
#     for i in range(len(arr)):
#         minimum = i
#         for j in range(i + 1, len(arr)):
#             if arr[j] < arr[minimum]:
#                 minimum = j
#         arr[minimum], arr[i] = arr[i], arr[minimum]
            
#     return arr
# sort_list = selection_sort(rand_list)
# print(sort_list)

# with open('file_random_numbers.txt', 'a') as data:
#     data.writelines(f"{sort_list}")

# 2.Дан список чисел. Создать список в который попадают числа, описывающие возрастающую последовательность и содержащие максимальное количество элементов. 
# Пример: [1, 5, 2, 3, 4, 6, 1, 7] => [1, 2, 3, 4, 6, 7]
#  [5, 2, 3, 4, 6, 1, 7] => [2, 3, 4, 6, 7]
#  Порядок элементов менять нельзя

## Нехватает ума сделать, чтобы из двух одинаковых значений массива приоритетов (reestr), выбирал правое, а не левое значение

# def lis(arr):
#     count = len(arr)
#     reestr = [1]*count
#     spisok = []
#     for i in range (1, count):
#         for j in range(0, i):
#             if arr[i] > arr[j] and reestr[i] < reestr[j] + 1:
#                 reestr[i] = reestr[j]+1                          
#     print(reestr)
#     num = 1
#     for i in range (0, count):
#         if num == reestr[i] and reestr[i] < reestr[i]+1:
#             spisok.append(arr[i])
#             num +=1
#     return spisok

# lst = [1, 5, 2, 3, 4, 6, 1, 7]
# print (lst,"=>", lis(lst))


# Экстра-задачи:
# 1. Давайте представим, что ваша компания только что наняла вашего друга из колледжа и заплатила вам реферальный бонус. 
# Потрясающе! Чтобы отпраздновать, вы берете свою команду в очень странный бар по соседству и используете реферальный бонус, 
# чтобы купить и построить самую большую трехмерную пирамиду из пивных банок, которую вы можете.
# Пирамида пивных банок будет квадратировать количество банок на каждом уровне - 1 банка на верхнем уровне, 4 на втором, 9 на следующем, 16, 25...
# Определите функцию beeramid, чтобы вернуть количество полных уровней пирамиды пивных банок, которую вы можете сделать, учитывая параметры: реферальный бонус и цена пивной банки.
# Например:
# beeramid(1500, 2)# 12
# beeramid(5000, 3)# 16

# 2. Создать функцию, которая из списка чисел возвращает число, 
# являющее суммой двух или нескольких других элементов, 
# либо возвращающее None, если такого числа нет.

# 3. Вот вам файл с английскими именами. https://cloud.mail.ru/public/J7aq/iHnLspVJR
# Начните с сортировки в алфавитном порядке. 
# Затем подсчитайте алфавитные значения каждого имени и умножьте это значение на порядковый номер имени в отсортированном списке для получения количества очков имени.
# Например, если список отсортирован по алфавиту, имя COLIN (алфавитное значение которого 3 + 15 + 12 + 9 + 14 = 53) является 938-м в списке. Поэтому, имя COLIN получает 938 × 53 = 49714 очков.
# Какова сумма очков имен в файле?