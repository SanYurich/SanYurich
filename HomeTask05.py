# 1. Напишите программу, удаляющую из текста все слова содержащие "абв", которое регистронезависимо. Используйте знания с последней лекции. Выполните ее в виде функции. 
# Пример: «абвгдеж рабав копыто фабв Абкн абрыволк аБволк»

# line = "абвгдеж рабав копыто фабв Абкн абрыволк аБволк"
# fragment = "абв"
# def Delite_words_fragment(words, search):
#     words = line.split(' ')
#     new_words = []
#     for word in words:
#         if search not in word:
#             new_words.append(word)
#     return new_words
# print(Delite_words_fragment(line, fragment))


# 2. Вы когда-нибудь играли в игру "Крестики-нолики"? Попробуйте создать её, причем чтобы сыграть в нее можно было в одиночку. 

# #Инициализация карты
# maps = [1,2,3,
#         4,5,6,
#         7,8,9]
 
# # Инициализация победных линий
# victories = [[0,1,2],
#              [3,4,5],
#              [6,7,8],
#              [0,3,6],
#              [1,4,7],
#              [2,5,8],
#              [0,4,8],
#              [2,4,6]]
 
# # Вывод карты на экран
# def print_maps():
#     print(maps[0], end = " ")
#     print(maps[1], end = " ")
#     print(maps[2])
 
#     print(maps[3], end = " ")
#     print(maps[4], end = " ")
#     print(maps[5])
 
#     print(maps[6], end = " ")
#     print(maps[7], end = " ")
#     print(maps[8])
     
# # Сделать ход в ячейку
# def step_maps(step,symbol):
#     ind = maps.index(step)
#     maps[ind] = symbol
 
# # Получить текущий результат игры
# def get_result():
#     win = ""
 
#     for i in victories:
#         if maps[i[0]] == "X" and maps[i[1]] == "X" and maps[i[2]] == "X":
#             win = "X"
#         if maps[i[0]] == "O" and maps[i[1]] == "O" and maps[i[2]] == "O":
#             win = "O"   
             
#     return win
 
# #Искусственный интеллект: поиск линии с нужным количеством X и O на победных линиях
# def check_line(sum_O,sum_X):
 
#     step = ""
#     for line in victories:
#         o = 0
#         x = 0
 
#         for j in range(0,3):
#             if maps[line[j]] == "O":
#                 o = o + 1
#             if maps[line[j]] == "X":
#                 x = x + 1
 
#         if o == sum_O and x == sum_X:
#             for j in range(0,3):
#                 if maps[line[j]] != "O" and maps[line[j]] != "X":
#                     step = maps[line[j]]
                 
#     return step
 
# #Искусственный интеллект: выбор хода
# def AI():        
 
#     step = ""
 
#     # 1) если на какой либо из победных линий 2 свои фигуры и 0 чужих - ставим
#     step = check_line(2,0)
 
#     # 2) если на какой либо из победных линий 2 чужие фигуры и 0 своих - ставим
#     if step == "":
#         step = check_line(0,2)        
 
#     # 3) если 1 фигура своя и 0 чужих - ставим
#     if step == "":
#         step = check_line(1,0)           
 
#     # 4) центр пуст, то занимаем центр
#     if step == "":
#         if maps[4] != "X" and maps[4] != "O":
#             step = 5           
 
#     # 5) если центр занят, то занимаем первую ячейку
#     if step == "":
#         if maps[0] != "X" and maps[0] != "O":
#             step = 1           
   
#     return step
 
# # Основная программа
# game_over = False
# human = True
 
# while game_over == False:
 
#     # 1. Показываем карту
#     print_maps()
 
#     # 2. Спросим у играющего куда делать ход
#     if human == True:
#         symbol = "X"
#         step = int(input("Человек, ваш ход: "))
#     else:
#         print("Компьютер делает ход: ")
#         symbol = "O"
#         step = AI()
 
#     # 3. Если компьютер нашел куда сделать ход, то играем. Если нет, то ничья.
#     if step != "":
#         step_maps(step,symbol) # делаем ход в указанную ячейку
#         win = get_result() # определим победителя
#         if win != "":
#             game_over = True
#         else:
#             game_over = False
#     else:
#         print("Ничья!")
#         game_over = True
#         win = "дружба"
 
#     human = not(human)        
 
# # Игра окончена. Покажем карту. Объявим победителя.        
# print_maps()
# print("Победил", win)   

# 3. Вот вам текст:
# «Ну, вышел я, короче, из подъезда. В общем, короче говоря, шел я, кажется, в магазин. 
# Ну,эээ, в общем, было лето, кажется. Как бы тепло. Солнечно, короче. Иду я, иду, в общем, по улице, а тут, короче, яма. 
# Я, эээээ…. Упал в нее. И снова вышел, короче, из подъезда. Ясен пень, в магазин. 
# В общем, лето на дворе, жарко, солнечно, птицы, короче, летают. Кстати, иду я по улице, иду, а тут, короче, яма. 
# Ну, я в нее упал, в общем. Вышел из подъезда, короче. Лето на дворе, ясен пень. Птицы поют, короче, солнечно. 
# В общем, в магазин мне надо. Что-то явно не так, короче. «Рекурсия», - подумал я. Ээээ...короче, в общем, пошел другой дорогой и не упал в эту… ээээ… яму. Хлеба купил».
# Отфильтруйте его, чтобы этот текст можно было нормально прочесть. Предусмотрите вариант, что мусорные слова могли быть написаны без использования запятых.

# import re

# text = 'Ну, вышел я, короче, из подъезда. В общем, короче говоря, шел я, кажется, в магазин. Ну,эээ, в общем, было лето, кажется. Как бы тепло. Солнечно, короче. Иду я, иду, в общем, по улице, а тут, короче, яма. Я, эээээ…. Упал в нее. И снова вышел, короче, из подъезда. Ясен пень, в магазин. В общем, лето на дворе, жарко, солнечно, птицы, короче, летают. Кстати, иду я по улице, иду, а тут, короче, яма. Ну, я в нее упал, в общем. Вышел из подъезда, короче. Лето на дворе, ясен пень. Птицы поют, короче, солнечно. В общем, в магазин мне надо. Что-то явно не так, короче. «Рекурсия», - подумал я. Ээээ...короче, в общем, пошел другой дорогой и не упал в эту… ээээ… яму. Хлеба купил.'
# words_text = re.findall("[\w']+|[.,«»]", text)
# unwanted = {'Ну','короче','эээ',','}
# words_text = [e for e in words_text if e not in unwanted]
# print(" ".join(words_text))

# 4. Чисто для тренировки новый функций, ничего сложного. Создайте два списка — один с названиями языков программирования, другой — с числами от 1 до длины первого плюс 1. 
# Вам нужно сделать две функции: первая из которых создаст список кортежей, состоящих из номера и языка, написанного большими буквами. 
# Вторая — которая отфильтрует этот список следующим образом: если сумма очков слова имеет в делителях номер, с которым она в паре в кортеже, 
# то кортеж остается, его номер заменяется на сумму очков. 
# Если нет — удаляется. Суммой очков называется сложение порядковых номеров букв в слове. 
# Порядковые номера смотрите в этой таблице, в третьем столбце: https://www.charset.org/utf-8
# Это — 16-ричная система, поищите, как правильнее и быстрее получать эти символы. С помощью reduce сложите получившиеся числа и верните из функции в качестве ответа.
# Приписка: По домашнему заданию номер 4:
# 1. Список из чисел от 1 до длины первого плюс один - это опечатка. Для списка из двух языков:
# ['python', 'go']
# [1, 2]
# 2. Список кортежей, состоящих из номера и языка:
# [(1, 'python'), (2, 'go')]
# 3. По поводу таблицы - да поможет вам функция ord.

# from functools import reduce


# spisok_title = ['python', 'go']
# spisok_number = [1, 2]

# def function_zip(lst1,lst2):
#     data = list(zip(lst1,lst2))
#     return data
# print(f'zip - {function_zip(spisok_number,spisok_title)}')

# def one_function(spisok): 
#     enumer = list(enumerate(spisok,1))
#     return enumer
# korteg = one_function(spisok_title)
# print(f'enumerate - {korteg}')

# def two_function(spisok):
#     lst = []
#     for index, name in spisok:
#         sum_ball = reduce(lambda x, y: x + ord(y), name, 0)
#         delit = [i for i in range(1, sum_ball)]
#         if index in delit:
#             lst.append((sum_ball, name))
#     return (lst)
# print(two_function(korteg))

# Экстра-задачи:
# 1. Супер-сложная.
# Совершенным числом называется число, у которого сумма его делителей равна самому числу. Например, сумма делителей числа 28 равна 1 + 2 + 4 + 7 + 14 = 28, что означает, что число 28 является совершенным числом.
# Число n называется недостаточным, если сумма его делителей меньше n, и называется избыточным, если сумма его делителей больше n.
# Так как число 12 является наименьшим избыточным числом (1 + 2 + 3 + 4 + 6 = 16), наименьшее число, которое может быть записано как сумма двух избыточных чисел, равно 24. Используя математический анализ, можно показать, что все целые числа больше 28123 могут быть записаны как сумма двух избыточных чисел. Эта граница не может быть уменьшена дальнейшим анализом, даже несмотря на то, что наибольшее число, которое не может быть записано как сумма двух избыточных чисел, меньше этой границы.
# Найдите сумму всех положительных чисел, которые не могут быть записаны как сумма двух избыточных чисел.

# 2. Единичная дробь имеет 1 в числителе. Десятичные представления единичных дробей со знаменателями от 2 до 10 даны ниже:
# 1/2=0.5
# 1/3=0.(3)
# 1/4=0.25
# 1/5=0.2
# 1/6=0.1(6)
# 1/7=0.(142857)
# 1/8=0.125
# 1/9=0.(1)
# 1/10=0.1
# Где 0.1(6) значит 0.166666..., и имеет повторяющуюся последовательность из одной цифры. Заметим, что 1/7 имеет повторяющуюся последовательность из 6 цифр.
# Найдите значение d < 1000, для которого 1/d в десятичном виде содержит самую длинную повторяющуюся последовательность цифр.

# 3. Начиная с числа 1 и двигаясь дальше вправо по часовой стрелке, образуется следующая спираль 5 на 5:
# 21 22 23 24 25
# 20  7  8  9 10
# 19  6  1  2 11
# 18  5  4  3 12
# 17 16 15 14 13
# Можно убедиться, что сумма чисел в диагоналях равна 101. (1+3+5+7+9+13+17+21+25)
# Какова сумма чисел в диагоналях спирали 1001 на 1001, образованной таким же способом?